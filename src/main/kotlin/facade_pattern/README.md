## 介绍

- 正如我们在使用电脑时，并不需要知道电脑的功能是怎么实现，我们只需使用电脑暴露出来的显示屏和键盘等，就能使用整台电脑的功能，这里说的显示屏和键盘等，就是电脑提供的一个表示其自身的 **外观**，所以，我们在代码过程中，往往也不需要知道相关对象系统的具体实现细节，只需要通过其提供出来的 **外观**，就能直接使用其功能
- 相当于在调用层和实现层之间，插入了一层，对实现层的方法进行了封装，调用层直接调用中间层的封装即可完成相应操作

## 作用

- **提供一种访问特定子系统功能的便捷方式**，其知道该 **子系统** 的一系列操作，但我们只需要怎么使用，而不用关心实现
- 注意：**外观模式，一般是作用在整个子系统上的**

## 何时使用

- 当需要对一个复杂的子系统进行调用时，但又不希望将子系统的复杂性引入，就可以考虑使用外观模式了
    - 复杂的子系统，往往意味着更加繁琐的调用步骤和调用细节，可以使用外观模式对其进行封装，再调用
    - 复杂的子系统，也意味着内部可能有很多功能，是我们所不需要的，此时可以通过 **外观模式**，对需要用到的功能进行暴露，从而降低了调用层的调用负担

## 流程图

![image-20220912152721683](https://raw.githubusercontent.com/CoderWDD/myImages/main/blog_images/image-20220912152721683.png)

## 优缺点

### 优点

- **解耦合**，可以将调用层与相应的复杂子系统解耦

### 缺点

- **外观层，过于耦合**，因为调用层的解耦合，实际是通过牺牲外观层来实现的，如果外观层中对过多的复杂子系统进行调用，就会导致外观层与其他的复杂子系统高度耦合